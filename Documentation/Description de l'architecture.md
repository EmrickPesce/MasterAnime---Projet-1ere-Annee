# Description de l’architecture de l’application MasterAnime : #

Pour décrire l’application, on va commencer par se pencher sur sa base, étant les différentes classes utiles à celle-ci. Tout d’abord, nous voulions pouvoir faire des listes d’animé et de scans. Puis, nous nous sommes dit qu’il serait mieux d’élargir cela pour avoir le plus d’utilisateurs possible, en mettant des œuvres. Celles-ci ont différents types, mais on a choisi de mettre des films, séries, livres, scans, animés et pour tous les autres types, le type autre. On commence alors à voir une base, avec la classe Oeuvre possédant diverses informations que chaque type d’œuvre va avoir, tel qu’une date de sortie, un nom, des informations complémentaires, un synopsis. Ensuite les œuvres ont des informations qui différent, un film va avoir un réalisateur, tandis qu’un animé va avoir un auteur. Les films et les séries ont les mêmes informations, donc nous les avons regroupés en une classe Cinématographique. Ceci en va de même pour les livres et scans, avec la classe Littéraire. C’est ainsi qu’est fait le lien d’héritage. Oeuvre, Cinématographique et Littéraire sont abstract dans la mesure où elles n’ont pas d’utilité à être instanciées, elles sont là pour éviter de réécrire plusieurs fois la même chose.

A l’intérieur de classe Oeuvre se trouve des informations complémentaires. Celles-ci viennent en couple de nom de l’information et l’information en elle-même. On remarque alors que c’est un Dictionary. Cependant, un Dictionary normal ne pourra notifier la vue d’un quelconque changement, ce qui est problématique dans notre cas. Ainsi, suite aux conseils de notre professeur, nous avons récupéré une classe ObservableDictionary trouvée sur internet, et implémentant toutes les notifications nécessaires pour que la vue soit correctement changée. Nous avons alors ici le patron de conception Observateur, qui nous explique qu’un sujet possède une méthode qui va notifier d’un changement d’état, via un événement. Nous avons également un observateur, qui ici est notre vue, qui va s’abonner à l’événement de changement d’état, et qui, à chaque fois que l’événement va être levé, va lancer une méthode pour changer son propre état, étant en corrélation avec celui du sujet. Par ailleurs, chaque type type d’œuvre possède des caractéristiques à respecter, avec notamment les différentes informations ne pouvant posséder plus de 16 caractères. Nous avons alors implémenté IDataErrorInfo afin que la vue puisse être modifiée suivant les données que l’utilisateur entre. Cependant, ceci ne fonctionne pas sur les clés et valeurs d’un Dictionary. Ainsi, pour parer à ce problème, nous avons créé une nouvelle classe StringVérifié implémentant IDataErrorInfo et possédant un attribut LeString, qui a maximum 16 caractères. Ainsi, la vue va pouvoir regarder les erreurs de StringVérifié et non celles du Dictionary, et donc être modifiée suivant cela. De plus, la classe Oeuvre hérite de ObservableObject, étant une classe implémentant INotifyPropertyChange, afin de notifier la vue à chaque modification d’un élément de l’œuvre. Par la suite, chaque Oeuvre possède un Guid afin de pouvoir les différencier pour le GetHashCode, bien que deux œuvres soient dites égales si elles ont le même nom.

L’objectif de l’application est de pouvoir créer des listes d’œuvres. Ainsi, nous avons une classe Bibliothèque, qui va posséder une collection d’Oeuvre. Pour que la vue prenne bien en compte les différents changements, c’est une ObserableCollection. Une Bibliothèque va posséder un nom et une image, qui pourront être modifiés par l’utilisateur. Ainsi, la classe Bibliothèque hérite de ObservableObject afin de notifier la vue de ses changements. La collection d’œuvre ne peut changer, dans le sens où elle gardera la même référence, mais ses éléments seront modifiés. Comme pour les Oeuvre, une Bibliothèque possède un Guid pour le GetHashCode, même si deux Bibliothèques possédants le même nom seront les mêmes. Chaque Bibliothèque possède une méthode pour rechercher une Oeuvre suivant différents critères tel que le type d’œuvre ou sa date, et donc avec un référentiel par rapport à celle-ci. Ainsi, nous avons ajouté deux énumérations, un pour le type TypeOeuvre, et un autre pour le référentiel DateQuand. Par conséquent la classe Bibliothèque dépend de ces deux énumérations.

L’application va posséder une liste regroupant toutes ses œuvres, ainsi qu’une collection de liste d’œuvres. Autrement dit, nous avons la classe Manager qui va permettre de stocker les données de l’application. Ainsi, celle-ci va contenir une Bibliothèque nommée ListePrincipale qui contiendra toutes les œuvres de l’application. De plus, elle contient une ObservableCollecion de Bibliothèque, qui seront alors les différentes listes de l’utilisateur. La ListePrincipale contenant toutes les œuvres de l’application va donc gérer ces dernières. C’est-à-dire que si une œuvre est supprimée dans cette Bibliothèque, alors elle sera complétement supprimée de l’application. On est donc sur une composition. Cependant, ceci n’est pas la même chose pour les autres Bibliothèque. En effet, en supprimant une œuvre d’une autre Bibliothèque, elle sera toujours présente dans la ListePrincipale, et nous aurons alors affaire à une agrégation. La clase Manager va également posséder d’autres attributs pour faciliter la mise en place de la partie WPF. En effet, nous avons une ObservableCollection nommée VuDesBibliothèques qui contient la ListePrincipale ainsi que les toutes les Bibliothèque du Manager. Ensuite, nous avons BibliothèqueSélectionnée et OeuvreSélectionnée possédant la référence de l’objet courant sélectionné par l’utilisateur dans l’application. Cette classe possède une méthode pour modifier une Oeuvre, et va donc utiliser ObservableDictionary et StringVérifié, ce qui fait qu’elle dépend aussi de ces classes. On pourrait penser que nous avons utilisé le patron de conception Façade, cependant la classe Manager ne permet pas d’utiliser toutes les fonctionnalités de l’application. En effet, même pour une utilisation normale, il faut accéder aux méthodes de la classe Bibliothèque, pour par exemple faire une recherche d’œuvre. Par la suite, le constructeur de la classe prend en paramètre une interface IBibliothèqueDataManager, d’où elle va tirer toutes ses données, et va également pouvoir les sauvegarder et charger à partir d’un fichier de sauvegarde, suivant le type de persistance utilisé. Elle est donc aussi dépendante de cette interface.

IDataManager est une interface généralisée pour la gestion de données d’une persistance. C’est-à-dire que ses méthodes seront utiles pour les persistances. IPersistanceManager et IBibliothèqueDataManager sont basées sur le même principe, mais ces interfaces sont axées sur l’application. En effet, les méthodes de IPersistanceManager vont permettre d’enregistrer et de récupérer différentes données utiles à l’application dans un fichier de persistance, et IBibliothèqueDataManager va rajouter des méthodes utiles à l’application, pour, par exemple, implémenter l’utilisation d’une Bibliothèque principale. De plus, celle-ci implémente les deux interfaces précédentes. Par conséquent, le Manager va se baser sur les méthodes présentes dans cette dernière interface afin de sauvegarder et récupérer les différentes données de la persistance choisie. En effet, toute classe implémentant ces méthodes pourra faire office de persistance. Ainsi, bien que l’application ne possède qu’une persistance Json, elle pourra évoluer vers une autre persistance, tel que XML, en créant une classe implémentant l’interface IBibliothèqueDataManager. IPersistanceManager dépend de la classe Bibliothèque. IBibliothèqueDataManager dépend des classes Bibliothèque et Oeuvre.

Ainsi, comme dit précédemment, l’application possède une persistance en Json. Pour ce faire, la classe PersistanceJson est présente et implémente IBibliothèqueDataManager. Alors, elle va pouvoir faire tout ce que les interfaces mères demandent. C’est-à-dire qu’elle possède, comme le Manager, une Bibliothèque principale et une collection de Bibliothèque. Elle va ainsi pouvoir passer ses données au Manager au travers de ses méthodes. De plus, elle pourra enregistrer et récupérer ses données dans son fichier de persistance, étant en Json. Elle peut également exporter ses données dans un autre fichier, et en importer à partir d’un nouveau. Son constructeur demande un booléen (étant à false par défaut) pour savoir si les données doivent être chargées à partir de la classe DonnéesPrêtes, donnant des données prédéfinies, ou à partir du fichier de persistance. Pour ce second cas, la classe VérifierDonnées, permet, comme son nom l’indique, de vérifier les données des différentes classes du Manager. En effet, elle va vérifier la taille des informations et noms des œuvres, ou encore la concordance des œuvres des Bibliothèques et de celles de la ListePrincipale, ainsi de suite. Ceci en est de même lors de l’importation. Pour pouvoir convertir les différentes données en Json, et inversement, nous avons mis une classe à part, pour une meilleure évolutivité. Celle-ci est ConvertisseurJson, et va donc convertir les différentes classes et données de l’application en Json, et de même dans le sens inverse. Comme on peut s’en douter, ces deux classes utilisent des Oeuvre et Bibliothèque, elles dépendent alors de ces mêmes classes.

Ensuite, nous avons la partie WPF. Celle-ci est principalement basée sur une fenêtre principale, la MainWindow, où différents contrôles utilisateurs seront affichés suivant ce que l’utilisateur fait. Ainsi, nous avons par exemple une page principale qui affichera les différentes œuvres présentes dans la bibliothèque sélectionnée par l’utilisateur, une page affichant une œuvre précise, ou encore une autre permettant de rechercher différentes œuvres de l’application. Pour faciliter le changement d’affichage, on a créé une classe Navigateur qui instancie tous les users controls, en possédant un UserControlSélectionné (récupéré par la MainWindow), et qui possède des méthodes tel que NaviguerVers ou NaviguerVersAncien. Elle possède également des constantes de string, pour connaitre quel user control on souhaite. De plus, ceux-ci sont présents dans un Dictionary de string et user control pour garder les mêmes instances. NaviguerVers ne va pas seulement changer le user control sélectionné, mais va également remettre à jour l’affichage. C’est-à-dire qu’il va changer les valeurs présentes dans les users controls par rapport aux actions de l’utilisateur. Par exemple, si l’utilisateur créait une nouvelle œuvre, il va recharger l’affichage des œuvres des Bibliothèques pour qu’elle soit présente. NaviguerVersAncien en fera de même dans la mesure où il appellera cette méthode en passant en paramètre l’ancienne page.

Il n’est pas utile de créer plusieurs Navigateur pour une même application, ce serait même plutôt perturbant. Ainsi, nous avons implémenté le patron de conception Singleton. Pour se faire, nous avons un attribut Navigateur avec la valeur null de base dans la classe Navigateur. Ensuite, nous avons ajouté une méthode GetInstance, qui retournera la valeur de l’attribut. Évidemment, le constructeur de la classe est passé en privé pour que personne ne puisse créer une nouvelle instance. Enfin, GetInstance vérifiera, avant de renvoyer la valeur, si elle est null. Si c’est le cas il instanciera un nouveau Navigateur qu’il mettra dans l’attribut, pour ensuite le retourner. La partie WPF utilise les différentes méthodes des classes suivant ce que l’utilisateur fait. Dans l’App, on a instancié un Manager qui est récupéré par la plupart des users controls suivant leurs besoins. Une classe Utilitaire est également présente pour regrouper différentes méthodes utiles à plusieurs users controls. Celle-ci n’en possède qu’une, mais il est envisageable d’en avoir plus pour une potentielle évolution. Cette unique méthode est ExplorateurImage qui va ouvrir une fenêtre de dialogue avec l’utilisateur pour qu’il choisisse une image dans ses dossiers. Ensuite, celle-ci sera enregistrée dans un dossier spécial présent dans ceux de l’application. Si le nom est déjà pris, il sera modifié. Par la suite, pour afficher ces images, un convertisseur est présent. Celui-ci prendra en paramètre le nom de l’image voulue, et ira chercher dans le dossier où se trouve les images enregistrées par l’utilisateur, celle qui possède le même nom, pour ensuite renvoyer le Uri de celle-ci. Si elle n’est pas trouvée, une autre image le signalant sera affichée. Il est possible pour l’utilisateur d’exporter ses données dans un autre fichier que celui de la persistance. Pour cela il doit sélectionner un dossier où le déposer. Ainsi, la partie WPF possède un package NuGet nommé Ookii.Dialogs, qui permet d’afficher une fenêtre de dialogue où l’utilisateur va sélectionner son dossier souhaité. Un mode nuit est présent dans les paramètres. Celui-ci va modifier les différentes ressources de la partie WPF pour afficher un thème plus sombre, et donc plus propice à la nuit. Ces ressources sont initialisées et modifiées via le Navigateur pour une meilleure évolutivité. Pour que notre application ait une meilleure esthétique, nous avons utilisé une ressource extérieure, le thème MaterialDesign en ayant mis comme couleur de base le bleu. Ceci a également permis d’utiliser différentes icônes pour un meilleur rendu.

Pour finir, nous avons le setup de l’application. Celui-ci va créer un dossier MasterAnime contenant les différents fichiers utiles à l’application. Nous avons alors à l’intérieur un dossier Application pour tous les éléments de publication. Ensuite, nous avons le dossier Images, qui contiendra toutes les images de l’utilisateur, mais aussi celles prêt-mises pour que l’application ne soit pas vide à l’installation. Enfin, nous avons le répertoire Json, qui contient le fichier de persistance contenant les données de l’application, et donc de l’utilisateur. Celui-ci possède également un fichier de base, aussi pour que l’application ne soit pas vide à l’installation. Pour finir, autre que dans ces dossiers, sur le bureau de l’utilisateur, sera présent un raccourcir permettant de lancer l’application.

